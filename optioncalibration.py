# %%import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.integrate import quadfrom scipy.optimize import minimizefrom datetime import datetime, timedeltaimport yfinance as yffrom nelson_siegel_svensson import NelsonSiegelSvenssonCurvefrom nelson_siegel_svensson.calibrate import calibrate_nss_ols# %%def options_df(symbol):        tk = yf.Ticker(symbol)        # Expiration dates    exps = tk.options    # Get options for each expiration    options_list = []    for e in exps:        opt = tk.option_chain(e)        opt_df = pd.concat([opt.calls], ignore_index=True)        opt_df['expirationDate'] = e        options_list.append(opt_df)    # Concatenate all DataFrames in the list    options = pd.concat(options_list, ignore_index=True)        # Bizarre error in yfinance that gives the wrong expiration date        # Add 1 day to get the correct expiration date    options['expirationDate'] = pd.to_datetime(options['expirationDate']) + timedelta(days=1)    options['dte'] = (options['expirationDate'] - datetime.today()).dt.days / 365            options[['bid', 'ask', 'strike']] = options[['bid', 'ask', 'strike']].apply(pd.to_numeric)    options['mark'] = (options['bid'] + options['ask']) / 2 # Calculate the midpoint of the bid-ask    options['volume'] = options['volume'].fillna(method='ffill')    # Drop unnecessary and meaningless columns    options = options.drop(columns = ['contractSize', 'currency', 'change', 'percentChange', 'lastTradeDate', 'lastPrice', 'contractSymbol', 'bid', 'ask', 'openInterest', 'inTheMoney', 'expirationDate'])        return options# %%msft = options_df("MSFT")print(msft)# %%aapl = options_df("AAPL")print(aapl)# %%nvda = options_df("NVDA")print(nvda)# %%amzn = options_df("AMZN")print(amzn)# %%googl = options_df("GOOGL")print(googl)# %%tsla = options_df("TSLA")print(tsla)# %%meta = options_df("META")print(meta)# %%amd = options_df("AMD")print(amd)# %%shop = options_df("SHOP")print(shop)# %%now = options_df("NOW")print(now)# %%def heston_charfunc(phi, S0, v0, kappa, theta, sigma, rho, lambd, tau, r):    a = kappa*theta    b = kappa+lambd    rspi = rho*sigma*phi*1j        d = np.sqrt( (rho*sigma*phi*1j - b)**2 + (phi*1j+phi**2)*sigma**2 )    g = (b-rspi+d)/(b-rspi-d)    exp1 = np.exp(r*phi*1j*tau)    term2 = S0**(phi*1j) * ( (1-g*np.exp(d*tau))/(1-g) )**(-2*a/sigma**2)    exp2 = np.exp(a*tau*(b-rspi+d)/sigma**2 + v0*(b-rspi+d)*( (1-np.exp(d*tau))/(1-g*np.exp(d*tau)) )/sigma**2)        return exp1*term2*exp2# %%def heston_price_rec(S0, K, v0, kappa, theta, sigma, rho, lambd, tau, r):    args = (S0, v0, kappa, theta, sigma, rho, lambd, tau, r)    P, umax, N = 0, 100, 10000    dphi=umax/N #dphi is width    for i in range(1,N):        # rectangular integration        phi = dphi * (2*i + 1)/2 # midpoint to calculate height        numerator = np.exp(r*tau)*heston_charfunc(phi-1j,*args) - K * heston_charfunc(phi,*args)        denominator = 1j*phi*K**(1j*phi)        P += dphi * numerator/denominator    return np.real((S0 - K*np.exp(-r*tau))/2 + P/np.pi)# %%t = np.array([1/12, 2/12, 3/12, 4/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30])yields2 = np.array([5.51, 5.35, 5.25, 5.13, 4.92, 4.36, 3.90, 3.73, 3.65, 3.71, 3.81, 4.18, 4.10]).astype(float)/100yields2 = np.array([5.51, 5.35, 5.25, 5.13, 4.92, 4.36, 3.90, 3.73, 3.65, 3.71, 3.81, 4.18, 4.10]).astype(float)/100curve_fit2, status = calibrate_nss_ols(t,yields2)curve_fit2#%%def final_table(options):    # Pivot the table to have expiration dates as columns, strikes as rows, and 'mark' as values    strike_table = options.pivot_table(index='dte', columns='strike', values='mark')    volume_table = options.pivot_table(index='dte', columns='strike', values='volume')    # Drop rows where not all expirations have a strike price    strike_table.dropna(axis=1, inplace=True)    strike_table_reset = strike_table.reset_index()    strikeTable = strike_table_reset.melt(id_vars='dte', var_name='strike', value_name='mark')    volume_table.dropna(axis=1, inplace=True)    volume_table_reset = volume_table.reset_index()    volumeTable = volume_table_reset.melt(id_vars='dte', var_name='strike', value_name='volume')    strikeTable['volume'] = volumeTable['volume']    strikeTable['rate'] = strikeTable['dte'].apply(curve_fit2)    return strikeTableprint(final_table(aapl))#%%S0 = yf.Ticker("AAPL").history(period="1d")['Close'].iloc[-1]r = final_table(aapl)['rate'].to_numpy('float')K = final_table(aapl)['strike'].to_numpy('float')tau = final_table(aapl)['dte'].to_numpy('float')P = final_table(aapl)['mark'].to_numpy('float')volume = final_table(aapl)['volume'].to_numpy('float')def SqErr(x):    v0, kappa, theta, sigma, rho, lambd = [param for param in x]    err = 0    for i in range(len(K)):        price = heston_price_rec(S0, K[i], v0, kappa, theta, sigma, rho, lambd, tau[i], r[i])        err += (P[i] - price) ** 2    return err#%%x0 = [0.1, 3, 0.05, 0.3, -0.8, 0.03]bnds = [[1e-3,0.5], [1e-4,5], [1e-3,0.1], [1e-3,1], [-1,1], [-1,1]]result = minimize(SqErr, x0, tol = 1e-3, method='SLSQP', options={'maxiter': 1e4 }, bounds=bnds)result#%%#check if heston_price_rec is returning real numbersfor i in range(len(K)):    price = heston_price_rec(S0, K[i], v0, kappa, theta, sigma, rho, lambd, tau[i], r[i])    if not np.isfinite(price):        print(f"Invalid price at iteration {i}: {price}")